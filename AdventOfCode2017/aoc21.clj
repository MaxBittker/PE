(require '[clojure.string :as str])

(def input "../.# => ##./#../...
.#./..#/### => #..#/..../..../#..#")

(def input2 "../.. => #.#/##./..#
#./.. => ###/.##/..#
##/.. => ..#/.#./##.
.#/#. => ###/.##/###
##/#. => ###/#.#/.##
##/## => #.#/..#/.#.
.../.../... => ..../.#../##.#/#.#.
#../.../... => .##./#.../.##./#..#
.#./.../... => ...#/.#.#/###./##.#
##./.../... => #.##/..#./.#.#/..##
#.#/.../... => ..#./.#../.#.#/###.
###/.../... => #.#./.#../.#../....
.#./#../... => ..#./##../.###/###.
##./#../... => ..#./###./#.#./#.#.
..#/#../... => ..##/###./.#.#/#...
#.#/#../... => #.../...#/.#.#/#...
.##/#../... => ###./####/.###/#.##
###/#../... => #.../#.##/#.../.#.#
.../.#./... => .##./#.#./#..#/..#.
#../.#./... => #.../##.#/#.#./.##.
.#./.#./... => ##../.###/####/....
##./.#./... => #.#./..../###./.#.#
#.#/.#./... => ..../..../#.##/.##.
###/.#./... => ####/#.##/.###/#.#.
.#./##./... => ####/#..#/#.##/.##.
##./##./... => .#.#/#.##/####/.###
..#/##./... => .##./...#/.#.#/..#.
#.#/##./... => #..#/...#/.#../.##.
.##/##./... => ##../#..#/##../..##
###/##./... => ..##/..../#.../..##
.../#.#/... => ###./#.../##.#/.#.#
#../#.#/... => ..#./...#/#..#/#.##
.#./#.#/... => ##../..#./##../###.
##./#.#/... => .#.#/#.#./####/.##.
#.#/#.#/... => .##./.##./#.##/#..#
###/#.#/... => #..#/.##./..#./##..
.../###/... => ###./#..#/.###/#.##
#../###/... => #.../#..#/####/##..
.#./###/... => ###./.##./#..#/.###
##./###/... => #..#/##../.##./#.#.
#.#/###/... => ..#./...#/#.../...#
###/###/... => ...#/##../...#/#.##
..#/.../#.. => ##.#/.#.#/.##./###.
#.#/.../#.. => ###./#..#/.#.#/#.##
.##/.../#.. => ...#/.#.#/.###/###.
###/.../#.. => .#../...#/..#./.#..
.##/#../#.. => .#../...#/.##./..#.
###/#../#.. => .###/##.#/#.##/.###
..#/.#./#.. => ##.#/##../##../#...
#.#/.#./#.. => #.../.###/#.#./#...
.##/.#./#.. => ###./#.##/###./####
###/.#./#.. => .#../..##/##.#/##.#
.##/##./#.. => ##.#/##../.##./...#
###/##./#.. => .#.#/.#../####/.##.
#../..#/#.. => ..##/###./...#/##..
.#./..#/#.. => .#../...#/.#../..##
##./..#/#.. => ###./..##/###./.##.
#.#/..#/#.. => ####/.#.#/...#/..##
.##/..#/#.. => #..#/.#../#.##/####
###/..#/#.. => .#../#.##/#.##/.#..
#../#.#/#.. => ..#./#.##/.#../.##.
.#./#.#/#.. => ##../#.../#.#./###.
##./#.#/#.. => #..#/.##./####/.#..
..#/#.#/#.. => ##.#/..#./..#./.#.#
#.#/#.#/#.. => .#../..#./..#./..##
.##/#.#/#.. => ##../#.##/#.#./#.##
###/#.#/#.. => ##.#/..##/##../##.#
#../.##/#.. => .###/####/#.##/..##
.#./.##/#.. => #.#./.##./###./#.##
##./.##/#.. => ..#./#..#/####/...#
#.#/.##/#.. => ####/.#.#/##../##.#
.##/.##/#.. => #.#./#..#/.#.#/.##.
###/.##/#.. => .#../.##./.##./.###
#../###/#.. => #..#/###./##.#/##..
.#./###/#.. => #.#./#..#/..#./#..#
##./###/#.. => ..../##.#/####/...#
..#/###/#.. => ..../#.../##../#..#
#.#/###/#.. => ..#./.#../..../##.#
.##/###/#.. => #..#/###./##.#/.###
###/###/#.. => #.../.##./#.##/.##.
.#./#.#/.#. => ...#/#.../.#../##.#
##./#.#/.#. => .#.#/#.#./.#../#.##
#.#/#.#/.#. => #.##/.##./###./....
###/#.#/.#. => ##../#..#/#.../.###
.#./###/.#. => ###./#.../.#../#..#
##./###/.#. => ##../##../#.../#...
#.#/###/.#. => ##../.#.#/#.##/#.#.
###/###/.#. => #.##/##.#/#.#./#...
#.#/..#/##. => ..../..#./####/..##
###/..#/##. => #.../...#/#.#./#.#.
.##/#.#/##. => ..##/###./.##./#...
###/#.#/##. => .#../###./##.#/...#
#.#/.##/##. => .###/##../.###/..#.
###/.##/##. => .#.#/##.#/.##./.###
.##/###/##. => ..#./.#.#/.#../#..#
###/###/##. => ###./#..#/####/...#
#.#/.../#.# => .#.#/.#../.#.#/#...
###/.../#.# => #..#/##../.#../...#
###/#../#.# => ..../.#../#.../..##
#.#/.#./#.# => #.#./####/.#.#/.##.
###/.#./#.# => ..#./####/#..#/..##
###/##./#.# => .##./.#../#.##/.#.#
#.#/#.#/#.# => ##../..##/##.#/#.#.
###/#.#/#.# => .##./#..#/#..#/.#.#
#.#/###/#.# => ..#./.###/#.##/#.##
###/###/#.# => ###./###./.#.#/###.
###/#.#/### => #.##/..##/#..#/...#
###/###/### => ...#/.#../##.#/.##.")

(defn split-pattern [pattern-string]
    (vec
        (map 
            #(str/split % #"")
            (str/split pattern-string #"/"))))


(defn parse-rule [rule]
    (vec
        (map 
            split-pattern
            (str/split rule #" => "))))


(def rules 
    (map 
        parse-rule
        (str/split-lines input)))
      

(def start
  [
    ["." "#" "."]
    ["." "." "#"]
    ["#" "#" "#"]])

(def start2
    [
        ["." "#"]
        ["." "."]])
      
(def start8
  [ ["#" "#" "." "#" "#" "."]
    ["#" "." "." "#" "." "."]
    ["." "." "." "." "." "."]
    ["#" "#" "." "#" "#" "."]
    ["#" "." "." "#" "." "."]
    ["." "." "." "." "." "."]])


(defn depth [i]
    (if (coll? i)
        (inc (depth (first i)))
        0))

    
(defn transpose [g]
    (vec (apply map vector g)))


(defn rotate [g]
    (transpose (vec (reverse g))))


(defn rotate-rule [[i o]]
    [(rotate i)
     o])


(defn transpose-rule [[i o]]
    [(transpose i)
     o])


(defn orientations [g]
    (set
        (concat
            (take 4 (iterate rotate g))
            (take 4 (iterate rotate (transpose g))))))


(defn rule-orientations [r]
  (set
    (concat
        (take 4 (iterate rotate-rule r))
        (take 4 (iterate rotate-rule (transpose-rule r))))))

(def r-rules 
    (mapcat 
        rule-orientations
        rules))

(defn div2? [grid]
    (zero?
        (mod 
            (count grid)
            2)))
     

(defn apply-rule [grid]
;   (println "grid" grid)
  (second 
    (first
      (filter
        (fn [[i o]] (= grid i))
        r-rules))))


(defn cell-locs [s n]
    (for [x (range 2) y (range 2)]
        [(+ x (* 2 (mod n s)))
         (+ y (* 2 (int (/ n s))))]))


(defn split-locs [s]
     (map (partial cell-locs s)
        (range (* s s))))


(defn to-vec [i]
    (vec (map vec i)))

(defn grid-sample [grid locs]
    (to-vec
      (partition 2
        (map 
            (fn [loc] (get-in grid loc))
            locs))))


(defn break-2s [grid]
    (vec 
      (map 
        #(grid-sample grid %)
        (split-locs (/ (count grid) 2)))))

        

(defn from4x3x3to6x6 [grid]
    (vec 
        (map 
          (comp vec flatten)
          (concat    
            (transpose (take 2 grid))
            (transpose (take 2 (drop 2 grid)))))))


(defn from12x3to6x6 [grid]
    (from4x3x3to6x6 (partition 3 grid)))        
            

(defn break [grid]
    (if (div2? grid)
      (break-2s grid)
      (break-3s grid)))

(defn enhance [grid]
    ; (println (count grid) (depth grid))
    (case (count grid)
        3 (apply-rule grid)    
        4 (if (= 2 (depth grid))
            (map apply-rule (break-2s grid))
            (map enhance grid))))

(defn nh [grid n]
    (if (zero? n)
        grid
        (nh (enhance grid) (dec n))))

(defn filled [grid]
    (frequencies (flatten grid)))

(filled (nh start 0))
(filled (nh start 1))
(filled (nh start 2))
(filled (nh start 3))
(filled (nh start 4))
(filled (nh start 5))

;161 (too low)            
;362 
; (frequencies (flatten (n-hance start 5)))
; (frequencies (flatten (n-hance start 4)))

; (frequencies (flatten (n-hance start 3)))
; (frequencies (flatten (n-hance start 2)))
; (frequencies (flatten (n-hance start 1)))

; (depth)
; (n-hance start 2)
